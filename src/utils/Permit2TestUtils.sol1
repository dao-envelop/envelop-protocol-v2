// src/utils/Permit2TestUtils.sol
pragma solidity ^0.8.24;

import "../interfaces/ISignatureTransfer.sol";
import "forge-std/Test.sol";

library Permit2TestUtils {
    using stdStorage for StdStorage;
    
    Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
    
    function signPermit(
        ISignatureTransfer.PermitTransferFrom memory permit,
        uint256 privateKey,
        address permit2Address,
        address spender
    ) internal view returns (bytes memory) {
        bytes32 digest = getTypedDataHash(permit, permit2Address, spender);
        console.log("Generated digest:");
        console.logBytes32(digest);
        
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(privateKey, digest);
        
        console.log("Signature params:");
        console.log("v:", v);
        console.logBytes32(r);
        console.logBytes32(s);
        
        return abi.encodePacked(r, s, v);
    }
    
    function getTypedDataHash(
        ISignatureTransfer.PermitTransferFrom memory permit,
        address permit2Address,
        address spender
    ) internal view returns (bytes32) {
        // ВАЖНО: Получаем реальный DOMAIN_SEPARATOR из контракта Permit2
        // bytes32 domainSeparator = keccak256(
        //     abi.encode(
        //         keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
        //         keccak256("Permit2"),
        //         keccak256("1"),
        //         block.chainid,
        //         permit2Address
        //     )
        // );
        
        // Лучше получить реальный DOMAIN_SEPARATOR из контракта
        (bool success, bytes memory data) = permit2Address.staticcall(
            abi.encodeWithSignature("DOMAIN_SEPARATOR()")
        );
        
        bytes32 domainSeparator;
        if (success && data.length == 32) {
            domainSeparator = abi.decode(data, (bytes32));
            console.log("Real DOMAIN_SEPARATOR from contract:");
            console.logBytes32(domainSeparator);
        } else {
            // Fallback если не можем получить
            domainSeparator = keccak256(
                abi.encode(
                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                    keccak256("Permit2"),
                    keccak256("1"),
                    1, // mainnet chainId
                    permit2Address
                )
            );
        }
        
        // Хэш TokenPermissions
        bytes32 tokenPermissionsHash = keccak256(
            abi.encode(
                keccak256("TokenPermissions(address token,uint256 amount)"),
                permit.permitted.token,
                permit.permitted.amount
            )
        );
        
        console.log("TokenPermissions hash:");
        console.logBytes32(tokenPermissionsHash);
        
        // Согласно коду Permit2, spender ВКЛЮЧАЕТСЯ в structHash
        // Проверь исходник: https://github.com/Uniswap/permit2/blob/main/src/SignatureTransfer.sol
        bytes32 structHash = keccak256(
            abi.encode(
                keccak256("PermitTransferFrom(TokenPermissions permitted,address spender,uint256 nonce,uint256 deadline)"),
                tokenPermissionsHash,
                spender, // ← ВОТ ОН!
                permit.nonce,
                permit.deadline
            )
        );
        
        console.log("Struct hash:");
        console.logBytes32(structHash);
        
        bytes32 digest = keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
        return digest;
    }
    
    // Функция для отладки
    function recoverSigner(
        ISignatureTransfer.PermitTransferFrom memory permit,
        address permit2Address,
        address spender,
        bytes memory signature
    ) internal view returns (address) {
        bytes32 digest = getTypedDataHash(permit, permit2Address, spender);
        
        bytes32 r;
        bytes32 s;
        uint8 v;
        
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }
        
        return ecrecover(digest, v, r, s);
    }
}